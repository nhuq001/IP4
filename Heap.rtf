
typedef struct Data
{
    double event_time; // Min-heap ordered by this variable
    int subvolume;
} data;

typedef struct Heap
{
    int current_number_of_elements_in_array; // Default 0
    struct Data data [100];
} heap;

int get_left_child_index (int current_position);

int get_right_child_index (int current_position);

int get_parent_index (int current_position);


struct Data get_left_child (int index, struct Data data []);

struct Data get_right_child (int index, struct Data data []);

struct Data get_parent (int index, struct Data data[]);

bool has_left_child (int index, int current_number_of_elements_in_array);

bool has_right_child (int index, int current_number_of_elements_in_array);

bool has_parent (int index, int current_number_of_elements_in_array);


void add (struct Data element, struct Heap *heap);

void perlocate_up (struct Data data [], int current_number_of_elements);

void remove_element (struct Heap *heap);

void perlocate_down (struct Data data [], int current_number_of_elements);

void swap (struct Data data [], int indexOne, int indexTwo);

void print_heap_array (struct Heap heap);






int get_left_child_index (int current_position)
{
    return (current_position*2)+1;
}

int get_right_child_index (int current_position)
{
    return (current_position*2)+2;
}

int get_parent_index (int current_position)
{
    return (current_position-1)/2;
}


struct Data get_left_child (int index, struct Data data [])
{
    return data[get_left_child_index(index)];
}

struct Data get_right_child (int index, struct Data data [])
{
    return data[get_right_child_index(index)];
}

struct Data get_parent (int index, struct Data data [])
{
    return data[get_parent_index(index)];
}

bool has_left_child (int index, int current_number_of_elements_in_array)
{
    return get_left_child_index(index) < current_number_of_elements_in_array;
}

bool has_right_child (int index, int current_number_of_elements_in_array)
{
    return get_right_child_index(index) < current_number_of_elements_in_array;
}

bool has_parent (int index, int current_number_of_elements_in_array)
{
    return get_parent_index(index) < current_number_of_elements_in_array;
}

void add (struct Data element, struct Heap *heap)
{
    // The array does not resize itself
   
    heap->data[heap->current_number_of_elements_in_array] = element;
    heap->current_number_of_elements_in_array += 1;

    perlocate_up(heap->data, heap->current_number_of_elements_in_array);
}

void perlocate_up (struct Data data [], int current_number_of_elements)
{
    double event_time = data[current_number_of_elements-1].event_time;
    int index = current_number_of_elements-1;
    
    while (has_parent(index, current_number_of_elements) && event_time < get_parent(index, data).event_time)
    {
        swap(data, index,get_parent_index(index));
        index = get_parent_index(index);
    }
    
}

void remove_element (struct Heap *heap)
{
    if (heap->current_number_of_elements_in_array == 0)
    {
        return;
    }
    
    heap->data[0] = heap->data[heap->current_number_of_elements_in_array-1];
    
    // Dummy value
    struct Data new_data;
    new_data.event_time = -1;
    new_data.subvolume = -1;
    
    heap->data[heap->current_number_of_elements_in_array-1] = new_data;
    heap->current_number_of_elements_in_array-=1;
    
    perlocate_down(heap->data, heap->current_number_of_elements_in_array);
}

void perlocate_down (struct Data data [], int current_number_of_elements)
{
    double event_time = data[0].event_time;
    int index = 0;
    
    while (has_left_child(index, current_number_of_elements))
    {
        int smaller_index = get_left_child_index(index);
        
        if (has_right_child(index, current_number_of_elements) && get_right_child(index, data).event_time < get_left_child(index, data).event_time)
        {
            smaller_index = get_right_child_index(index);
        }
        
        if (event_time < data[smaller_index].event_time)
        {
            break;
        } else
        {
            swap(data, smaller_index, index);
        }
        index = smaller_index;
    }
}
           
void swap (struct Data data [], int indexOne, int indexTwo)
{
    struct Data temp = data[indexOne];
    data[indexOne] = data[indexTwo];
    data[indexTwo] = temp;
}

void print_heap_array (struct Heap heap)
{
    for (int i = 0 ; i < heap.current_number_of_elements_in_array ; i++)
    {
        printf("%f", heap.data[i].event_time);
        printf("---");
        printf("%d", heap.data[i].subvolume);
        printf("\n");
    }
}
